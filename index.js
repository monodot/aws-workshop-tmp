// This script was initially generated by Gemini.
import { trace } from '@opentelemetry/api';
import './instrumentation.js';

const tracer = trace.getTracer(
    'report-generator',
    '1.4.1',
);

/**
 * Simulates fetching large volumes of historical ticket purchase data from a database.
 * In a real scenario, this would involve SQL queries to an RDS instance.
 * For this demo, it generates dummy data to simulate the I/O and memory overhead.
 * @returns {Array<Object>} Simulated raw ticket data.
 */
function fetchSalesData() {
    return tracer.startActiveSpan('fetchSalesData', (span) => {
        console.log('  - Fetching sales data...');
        const numRecords = 1000000; // Simulate 1 million records for significant data
        const data = [];
        for (let i = 0; i < numRecords; i++) {
            data.push({
                ticketId: `TKT-${Math.random().toString(36).substr(2, 9)}`,
                eventId: `EVT-${Math.floor(Math.random() * 500)}`,
                price: parseFloat((Math.random() * 100 + 20).toFixed(2)),
                category: ['VIP', 'Standard', 'Discount', 'EarlyBird'][Math.floor(Math.random() * 4)],
                purchaseDate: new Date(Date.now() - Math.floor(Math.random() * 365 * 24 * 60 * 60 * 1000)).toISOString()
            });
        }

        span.end(); // Always be closing
        return data;
    });
}

/**
 * Simulates CPU and memory-intensive data aggregation and analysis.
 * @param {Array<Object>} data The raw ticket data.
 * @returns {Object} Aggregated report data.
 */
function aggregateTicketData(data) {

    return tracer.startActiveSpan('aggregateTicketData', (span) => {
        console.log('  - Aggregating and analyzing data...');

        const aggregationStartTime = process.hrtime.bigint(); // High-resolution time for performance measurement

        // Simulate CPU-intensive work (e.g., complex calculations, heavy looping)
        // Adjust 'iterations' to control the duration of CPU usage.
        // On a powerful machine, 1_000_000_000 might take 10-15 seconds.
        const iterations = 1_000_000_000;
        let result = 0;
        for (let i = 0; i < iterations; i++) {
            result += Math.sqrt(i) * Math.sin(i % 1000); // Simple calculation to keep CPU busy
        }

        // Simulate memory allocation (briefly hold a large array)
        // Allocates approximately 200MB of memory (20 * 1024 * 1024 * 8 bytes for doubles)
        const largeArray = new Array(20 * 1024 * 1024).fill(Math.random());
        // The array will be garbage collected when 'largeArray' goes out of scope,
        // simulating temporary memory usage.

        const totalRevenue = data.reduce((sum, item) => sum + item.price, 0);
        const ticketsByCategory = data.reduce((acc, item) => {
            acc[item.category] = (acc[item.category] || 0) + 1;
            return acc;
        }, {});

        const aggregationEndTime = process.hrtime.bigint();
        const durationMs = Number(aggregationEndTime - aggregationStartTime) / 1_000_000;
        console.log(`  - Aggregation completed in ${durationMs.toFixed(2)} ms.`);

        span.end(); // Always be closing
        return { totalRevenue, ticketsByCategory };
    });
}

/**
 * Simulates generating a summary report file or pushing aggregated data.
 * @param {Object} aggregatedData The aggregated report data.
 * @returns {string} Simulated report content.
 */
function generateReportOutput(aggregatedData) {
    return tracer.startActiveSpan('generateReportOutput', (span) => {
        console.log('  - Generating report output...');

        const reportContent = `Daily Sales Report - ${new Date().toLocaleDateString()}\n` +
            `Total Revenue: $${aggregatedData.totalRevenue.toFixed(2)}\n` +
            `Tickets by Category:\n${JSON.stringify(aggregatedData.ticketsByCategory, null, 2)}`;

        // Simulate file write or network push delay
        // This is a synchronous busy-wait for demonstration purposes.
        const writeDelayMs = 3000; // 3 seconds delay
        const writeStartTime = process.hrtime.bigint();
        while (Number(process.hrtime.bigint() - writeStartTime) / 1_000_000 < writeDelayMs) {
            // Busy-wait to simulate I/O bound delay
        }

        console.log('  - Report output generated.');

        span.end(); // Always be closing
        return reportContent;
    });
}

/**
 * The main function for the daily report generation job.
 * This function orchestrates the entire report generation process.
 */
async function runDailyReportJob() {

    return tracer.startActiveSpan('runDailyReportJob', (span) => {
        console.log('\n--- Starting Daily Ticket Sales Report Generation Job ---');

        try {
            const rawData = fetchSalesData();
            const aggregatedData = aggregateTicketData(rawData);
            const report = generateReportOutput(aggregatedData);
            console.log('--- Daily Ticket Sales Report Generation Job Completed ---');
            console.log('Generated Report (preview in console):');
            console.log(report); // Log the actual report content to console
        } catch (error) {
            console.error(`Error during report generation: ${error.message}`);
        }

        span.end();
    });


}

// --- Scheduler Logic ---
// This simple scheduler runs the job every 30 seconds for demonstration.
// In a real production environment, this would be a cron job, AWS Batch job,
// or triggered by an event.
let jobIntervalId = null;

function startScheduler() {
    if (jobIntervalId) {
        console.log("Scheduler already running.");
        return;
    }
    console.log("\nScheduler started. Running report job every 30 seconds (for demo purposes)...");
    // Run immediately and then every 30 seconds
    runDailyReportJob();
    jobIntervalId = setInterval(runDailyReportJob, 30000); // 30 seconds for demo
}

function stopScheduler() {
    if (jobIntervalId) {
        clearInterval(jobIntervalId);
        jobIntervalId = null;
        console.log("\nScheduler stopped.");
    } else {
        console.log("\nScheduler not running.");
    }
}

// Simple command-line interface to start/stop the job
if (process.argv[2] === 'start') {
    startScheduler();
    console.log("Press Ctrl+C to stop the scheduler.");
} else if (process.argv[2] === 'stop') {
    stopScheduler();
} else {
    console.log("Usage: node index.js [start|stop]");
    console.log("To run the daily report job repeatedly: node index.js start");
    console.log("To stop the scheduler (if running in a persistent process): node index.js stop");
    console.log("You can also just run 'node index.js' once to execute a single report job.");

    if (process.argv.length === 2) {
        runDailyReportJob();
    }
}

process.on('SIGINT', () => {
    console.log('\nShutting down scheduler...');
    stopScheduler();
    process.exit(0);
});
